"use strict";(self.webpackChunkgreenfield_docs=self.webpackChunkgreenfield_docs||[]).push([[9136],{72175:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=i(87462),r=(i(67294),i(3905));const o={title:"Piece Store"},a="Piece Store",s={unversionedId:"guide/storage-provider/modules/piece-store",id:"guide/storage-provider/modules/piece-store",title:"Piece Store",description:"Vision",source:"@site/docs/guide/storage-provider/modules/piece-store.md",sourceDirName:"guide/storage-provider/modules",slug:"/guide/storage-provider/modules/piece-store",permalink:"/greenfield-docs/docs/guide/storage-provider/modules/piece-store",draft:!1,editUrl:"https://github.com/bnb-chain/greenfield-docs/blob/main/docs/guide/storage-provider/modules/piece-store.md",tags:[],version:"current",frontMatter:{title:"Piece Store"},sidebar:"guideSidebar",previous:{title:"SPDB",permalink:"/greenfield-docs/docs/guide/storage-provider/modules/spdb"},next:{title:"Redundancy",permalink:"/greenfield-docs/docs/guide/storage-provider/modules/redundancy"}},c={},l=[{value:"Vision",id:"vision",level:2},{value:"Goal",id:"goal",level:2},{value:"Overview",id:"overview",level:2},{value:"API Interfaces",id:"api-interfaces",level:3},{value:"Sharding",id:"sharding",level:3},{value:"Compatible With Multi Object Storage",id:"compatible-with-multi-object-storage",level:3},{value:"Outlook",id:"outlook",level:3}],d={toc:l},u="wrapper";function p(e){let{components:t,...o}=e;return(0,r.kt)(u,(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"piece-store"},"Piece Store"),(0,r.kt)("h2",{id:"vision"},"Vision"),(0,r.kt)("p",null,"Write once, run on every storage service."),(0,r.kt)("h2",{id:"goal"},"Goal"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vendor-agnostic"),(0,r.kt)("li",{parentName:"ul"},"Production ready"),(0,r.kt)("li",{parentName:"ul"},"High performance"),(0,r.kt)("li",{parentName:"ul"},"High availability")),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The core function of PieceStore module is to be compatible with multiple object storage or KV storage such as S3, GCS, Azure Blob, Minio, Ceph, IPFS, DiskFile, Memory, etc. Different SP can use different object storage without caring about the underlying implementation."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"piece-store-flow",src:i(97221).Z,width:"2292",height:"1920"})),(0,r.kt)("div",{style:{textAlign:"center"}},(0,r.kt)("i",null,"PieceStore Architecture")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/greenfield-storage-provider/tree/master/store/piecestore"},"PieceStore code")),(0,r.kt)("h3",{id:"api-interfaces"},"API Interfaces"),(0,r.kt)("p",null,"PieceStore provides encapsulating interfaces for upper-layer services to use. Now these APIs are called by local package functions. We provide two interfaces to visit PieceStore as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// PieceOp is the helper interface for piece key operator and piece size calculate.\ntype PieceOp interface {\n    // SegmentPieceKey returns the segment piece key used as the key of store piece store.\n    SegmentPieceKey(objectID uint64, segmentIdx uint32) string\n    // ECPieceKey returns the ec piece key used as the key of store piece store.\n    ECPieceKey(objectID uint64, segmentIdx, redundancyIdx uint32) string\n    // ChallengePieceKey returns the  piece key used as the key of challenge piece key.\n    // if replicateIdx < 0 , returns the SegmentPieceKey, otherwise returns the ECPieceKey.\n    ChallengePieceKey(objectID uint64, segmentIdx uint32, redundancyIdx int32) string\n    // MaxSegmentPieceSize returns the object max segment piece size by object payload size and\n    // max segment size that comes from storage params.\n    MaxSegmentPieceSize(payloadSize uint64, maxSegmentSize uint64) int64\n    // SegmentPieceCount returns the segment piece count of object payload by object payload size\n    // and max segment size that comes from storage params.\n    SegmentPieceCount(payloadSize uint64, maxSegmentSize uint64) uint32\n    // SegmentPieceSize returns the segment piece size of segment index by object payload size and\n    // max segment size that comes from storage params.\n    SegmentPieceSize(payloadSize uint64, segmentIdx uint32, maxSegmentSize uint64) int64\n    // ECPieceSize returns the ec piece size of ec index, by object payload size, max segment\n    // size and chunk number that ths last two params comes from storage params.\n    ECPieceSize(payloadSize uint64, segmentIdx uint32, maxSegmentSize uint64, chunkNum uint32) int64\n    // ParseSegmentIdx returns the segment index according to the segment piece key\n    ParseSegmentIdx(segmentKey string) (uint32, error)\n    // ParseChallengeIdx returns the segment index and EC piece index  according to the challenge piece key\n    ParseChallengeIdx(challengeKey string) (uint32, int32, error)\n}\n\n// PieceStore is the interface to piece store that store the object payload data.\ntype PieceStore interface {\n    // GetPiece returns the piece data from piece store by piece key.\n    // the piece can segment or ec piece key.\n    GetPiece(ctx context.Context, key string, offset, limit int64) ([]byte, error)\n    // PutPiece puts the piece data to piece store, it can put segment\n    // or ec piece data.\n    PutPiece(ctx context.Context, key string, value []byte) error\n    // DeletePiece deletes the piece data from piece store, it can delete\n    // segment or ec piece data.\n    DeletePiece(ctx context.Context, key string) error\n}\n")),(0,r.kt)("p",null,"PieceOp interface describes how you can combine segmentPieceKey or ECPieceKey and PieceSize or PieceCount info. PieceStore interface describes what operations lower layer provide to interact. You can overwrite all methods of these two interfaces to implement your own functions. In the future, upper-layer services could visit PieceStore through HTTP, RPC or P2P which is more decentralized."),(0,r.kt)("h3",{id:"sharding"},"Sharding"),(0,r.kt)("p",null,"PieceStore provides sharding function for data high availability. PieceStore uses ",(0,r.kt)("inlineCode",{parentName:"p"},"fnv")," algorithm to shard piece data. If users want to use data sharding, you can configure ",(0,r.kt)("inlineCode",{parentName:"p"},"Shards = a(a is a number which 2 <= a <= 256)")," in config.toml."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note")," The current implementation of sharding can only be used for multiple buckets in one region. The support of multi-region would be added in the future which will be higher availability."),(0,r.kt)("h3",{id:"compatible-with-multi-object-storage"},"Compatible With Multi Object Storage"),(0,r.kt)("p",null,"PieceStore is vendor-agnostic, so it will be compatible with multi object storage. Now SP supports based storage such as ",(0,r.kt)("inlineCode",{parentName:"p"},"S3, MinIO, LDFS, OSS, DiskFile and Memory"),".\nRecommend using S3 or MinIO in production environment and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/greenfield-storage-provider/blob/master/store/piecestore/README.md"},"the releated config document is here"),". Users can experience PieceStore in local by DiskFile or Memory. The common interface is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// ObjectStorage is a common interface that must be implemented if some users want to use an object\n// storage (such as S3, Azure Blob, Minio, OSS, COS, etc)\ntype ObjectStorage interface {\n    // String the description of an object storage\n    String() string\n    // CreateBucket create the bucket if not existed\n    CreateBucket(ctx context.Context) error\n    // GetObject gets data for the given object specified by key\n    GetObject(ctx context.Context, key string, offset, limit int64) (io.ReadCloser, error)\n    // PutObject puts data read from a reader to an object specified by key\n    PutObject(ctx context.Context, key string, reader io.Reader) error\n    // DeleteObject deletes an object\n    DeleteObject(ctx context.Context, key string) error\n\n    // HeadBucket determines if a bucket exists and have permission to access it\n    HeadBucket(ctx context.Context) error\n    // HeadObject returns some information about the object or an error if not found\n    HeadObject(ctx context.Context, key string) (Object, error)\n    // ListObjects lists returns a list of objects\n    ListObjects(ctx context.Context, prefix, marker, delimiter string, limit int64) ([]Object, error)\n    // ListAllObjects returns all the objects as a channel\n    ListAllObjects(ctx context.Context, prefix, marker string) (<-chan Object, error)\n}\n")),(0,r.kt)("p",null,"If you want to use a new storage system, you can implement the methods of ObjectStorage interface. It's very convenient!"),(0,r.kt)("h3",{id:"outlook"},"Outlook"),(0,r.kt)("p",null,"PieceStore provides some fundamental functions: wrapped API interfaces, sharding and compatible with multiple storage systems. However, there are more functions to be added in the future."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Data Cache")),(0,r.kt)("p",null,"PieceStore is combined with object storage, cache is an important component for interacting efficiently between the local client and remote services. Read and write data can be loaded into cache in advance or asynchronously. Using caching technology can significantly reduce the latency of storage operations and increase data throughput compared to interact with remote services directly."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Data sync")),(0,r.kt)("p",null,"PieceStore will provide data synchronization for conveniently transferring data between different storage systems or different regions. Therefore, different SPs can do geo-disaster recovery backup to ensure high availability of data."))}p.isMDXComponent=!0},97221:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/11-SP-Piecestore-Arch-a6b8e2fa5b0539ac91ce69959de66367.jpg"}}]);